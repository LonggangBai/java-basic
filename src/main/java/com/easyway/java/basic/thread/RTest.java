package com.easyway.java.basic.thread;

/* ================================================================================== 
 * 文件：ThreadDemo07.java 
 * 描述：生产者－－消费者 
 * 注：其中的一些注释是我根据自己的理解加注的 
 * ================================================================================== 
 */
/**
 * <pre>
 * 
 * 学习java后，以前一直忙于跟着老师学习每天给我们灌入的知识，有些想做的小应用由于当时没有对javase部分的IO，Socket,Thread,Swing等有个较好的理解，我说的较好的理解是能够自己灵活运用这些东西做一些小的应用程序，比如我一直想做的有坦克大战，五子棋，基于TCP的多人聊天室，那时候也没有太多的时间去做，虽然这些都是一些基础，但对我来说还是有难度的，这里涉及到面向对象的分析和设计，在数学逻辑方面我觉得自己还是可以的，对面向对象的理解还有欠缺，昨天简单写了一篇文章，肤浅之谈，今天又想把前几天做的Swing小应用中对多线程浅浅的体会写下来。
 * 
 *  
 * 
 * 说到多线程，我可以由话说的，因为在我还没有结束培训之前，有家日资的公司来找人，人家就问我我对多线程的理解，还有进程和线程有什么区别？当时还在学习Struts，Hibernate和Spring主流框架,我就懵了，但不能说我懵了就可以啦，于是就搜肠刮肚，想啊，支支吾吾说了几句，俩面试官最后来了一句：其实并不是每个问题你都要回答上来的，因为那样我后面会有更多的问题等着你。言下之意是他一定能难到我的。后来要我了，由于我还没有毕业，培训没有结束，它们是做ios的，虽然ios也很有市场，我去的话，我喜欢的java都没有从事过具体的工作就要去学习ios，所以就没有去了，接下来还是学习java，此时我对javaSE部分还是印象比较深刻的，因为平时自己也在看相关的视屏，总结学习的东西。说到多线程，就从线程和进程开始吧。
 * 
 * 
 * 先简单说说概念：
 * 
 * 进程：一个程序开始运行时，就是一个进程，进程包括了运行中的程序和这个程
 * 
 * 序使用到的内存和系统资源，具有一定的虚拟地址空间，可自行代码，数据，对象
 * 
 * 句柄(句柄可以理解为对对象的应用，就是java中的应用变量)，环境变量，优先权
 * 
 * 等，一个进程可以由多个线程组成。
 * 
 * 线程：是进程的执行流，每个线程都有自己专有的寄存器(栈指针，程序计数器等)
 * 
 * 但代码区是共享的，即不同的线程可以访问同一个函数，它们共享同一个进程的系统资源。多线程是指一个进程中包含多个执行流，在一个程序中可以并发完成多个任务，提高效率。
 * 
 * 可以这么比方，我们一直在用windows系统中，由于我们同时启动了酷狗和QQ，就是听着音乐聊着天，更有厉害的挽着dota，那么着三个应用程序就是三个不同的进程，
 * 当我们在听歌的同时，突然想到了一首歌，要去搜索，下载，此时相当于有两个线程，播放和下载，同理QQ也是，所以可以理解为线程是进程中的进程，如果把一个进程看做为
 * Windows，当然这只是有助于理解，实际上进程和线程比这个复杂。
 * 
 * 那么说说联系，这样一说，联系就不难说了。
 * 
 *          联系：每一个进程都是从主线程开始执行的，它也可以在这个主线程中创建额外的线程，             一个线程只属于一个进程，一个进程可以拥有多个线程，同一个进程的所有线程                       共享该进程中所有的资源，处理机分给线程，真正在处理机上运行的是线程，
 * 
 * 一个线程的资源包括线程的机器寄存器设置，内核堆栈，线程环境变量和进程虚拟地址中的用户堆栈。
 * 
 * 肤浅的说说我的理解：
 * 
 *          理解：引入多线程可以给我们带来好处，首先线程可以按照我们的方式进行控制，易于        调度；通过线程可以实现并发性，可以让我们同时完成多个不同的任务；
 *          因为创建线程     比进程要快，开销要少；多个线程之间不需要等待，CPU可以切换执行，可以提高CPU     的执行率；当然，线程也是程序，会占用内存资源，
 *          而且需要协调和管理，需要CPU     的跟踪，多个线程访问共享资源时，形成竞争，而且会造成安全问题，线程过多会导致     控制复杂化，最终造成bug，
 *          所以要合理运用多线程。
 * 
 * 说了这么多，无非就是引入一些简单的概念，到底多线程是个什么东东，我用一句话总结一下，就是多线程是为了满足人类需要同时执行多个任务的欲望的。
 * 
 * 回到编码中，我说的是Java语言。在JDK中有一个Thread类是提供线程相关功能的类，其中还有个Runnable接口。
 * 
 * 提起类和接口，这些JDK类库中的类，让编程者可以利用的，继承和实现是我们常用的方式，说道继承，就想到了面向对象，它是面向对象中一个特性，是类的重构的一个重要手
 * 段，当然继承体系中有个里氏代换原则，就是继承是符合我们现实生活中的逻辑，具有相似的类可以从父类继承父类的成员，这里不是什么都可以继承的，比如说一个Bird类，
 * 有一个飞的方法，而我们说Penguin(企鹅)也是鸟类，是否可以继承自鸟类呢，当然代码上写法不会错，这不符合现实中的实际情况，所以是不合理的，里氏代换原则说的就是
 * 一个类的子类完全可以替换掉父类。接口是对行为的抽象，提供了一些行为，可以为一系列无关的类提供一个规范，往往多态的体现是通过继承和实现来实现的，在C++中有多
 * 重继承，而Java中摒弃了这种语法，就排出了多重继承中父类中存在相同方法的不同实现。实现也可以理解为多重继承，只不过是语法不同，还有接口这里专门指Interface，
 * 只能提供行为和常量，就是所有的变量默认是public static final ,方法时public的，不能定义变量。
 * 
 * 转到了面向对象那去了，本来自己就不怎么理解，还是回到正题，开始多线程之旅吧：
 * 
 *  
 * 
 * 前面说了什么是线程，那么如何启动线程呢，知道java的人都知道线程有两种常用的启动方法，当然JDK1.5以后有一个大家比较陌生的方式，提高里效率，后面会讲到。
 * 
 * 四、Java的等待通知机制
 * 　　在有些时候，我们需要在几个或多个线程中按照一定的秩序来共享一定的资源。例如生产者－－消费者的关系，
 * 在这一对关系中实际情况总是先有生产者生产了产品后，消费者才有可能消费；又如在父－－子关系中，总是先有父亲，
 * 然后才能有儿子。然而在没有引入等待通知机制前，我们得到的情况却常常是错误的。这里我引入《用线程获得强大的功能》
 * 一文中的生产者－－消费者的例子：
 * 
 * 
 * 　在以上的程序中，模拟了生产者和消费者的关系，生产者在一个循环中不断生产了从Ａ－Ｚ的共享数据，而消费者则不断地消费生产者生产的Ａ－Ｚ的共享数据。我们开始已经说过，在这一对关系中，必须先有生产者生产，才能有消费者消费。但如果运行我们上面这个程序，结果却出现了在生产者没有生产之前，消费都就已经开始消费了或者是生产者生产了却未能被消费者消费这种反常现象。为了解决这一问题，引入了等待通知（wait/notify)机制如下：
 * 　　１、在生产者没有生产之前，通知消费者等待；在生产者生产之后，马上通知消费者消费。
 * 　　２、在消费者消费了之后，通知生产者已经消费完，需要生产。
 * 下面修改以上的例子（源自《用线程获得强大的功能》一文）：
 * </pre>
 * 
 * @author Administrator
 * 
 */
// 共享的数据对象
class RShareData {
	private char c;

	public void setShareChar(char c) {
		this.c = c;
	}

	public char getShareChar() {
		return this.c;
	}
}

// 生产者线程
class RProducer extends Thread {

	private RShareData s;

	RProducer(RShareData s) {
		this.s = s;
	}

	public void run() {
		for (char ch = 'A'; ch <= 'Z'; ch++) {
			try {
				Thread.sleep((int) Math.random() * 4000);
			} catch (InterruptedException e) {
			}

			// 生产
			s.setShareChar(ch);
			System.out.println(ch + " producer by producer.");
		}
	}
}

// 消费者线程
class RConsumer extends Thread {

	private RShareData s;

	RConsumer(RShareData s) {
		this.s = s;
	}

	public void run() {
		char ch;

		do {
			try {
				Thread.sleep((int) Math.random() * 4000);
			} catch (InterruptedException e) {
			}
			// 消费
			ch = s.getShareChar();
			System.out.println(ch + " consumer by consumer.");
		} while (ch != 'Z');
	}
}

public class RTest {
	public static void main(String argv[]) {
		RShareData s = new RShareData();
		new RConsumer(s).start();
		new RProducer(s).start();
	}
}