/**
 * Project Name:java-basic
 * File Name:Sample.java
 * Package Name:com.easyway.java.basic.memory
 * Date:2015-3-23上午10:13:53
 * Copyright (c) 2015, longgangbai@sina.com All Rights Reserved.
 *
*/

package com.easyway.java.basic.memory;
/**
 * ClassName:Java 线程的运行机制 <br/>
 * Function: 在java虚拟机进程中，执行程序代码的任务是线程来完成的，每个线程都有一个程序计数器和方法调用栈。
 * 程序计数器：PC寄存器，当线程执行一个方法时候，程序计数器指向方法区中下一条要执行的字节码指令。
 * 方法调用栈：方法栈用来跟踪线程运行中一系列的方法调用过程，栈中的元素称为栈祯。每当线程调用一个方法的时候，
 * 就会向方法栈压入一个新 祯。祯用来存储方法的参数，局部变量和运算过程中的临时数据。
 * <br/>
 * Reason:	 
 * 栈祯 由以下三部分组成。
 *    局部变量区：存放局部变量和方法参数。
 *    操作数栈：是线程的工作区，用来存放运算过程中的生成的临时数据。
 *    栈数据区：为线程执行指令提供相关的信息，包括如何定位到位于堆区和方法区的特定数据，以及如何正常退出方法或者异常中断方法。
 * <pre>
 * ————————————————————————————————--       -----------------------
 * |    java栈区                                                     |       |   堆区                                       |         |————————————方法区————————————————————
 * |                                |       | ---------------------|         |                                |  
 * |    -----------------------     |       |   MemoryStyle 对象          |         |      ————————————————————      |
 * |    |    method()方法的栈祯      |    |       |     实例变量a          |         |      |MemoryStyle类数据结构    |     |
 * |    |--------------------- |    |       |                      |         |      |  ————————————————— |    |
 * |    |       局部变量b        |    |       | —————————————————————|         |      |  method()方法字节码      |    |  
 * |    | _____________________|    |                                        |      |        代表a++操作指令|    |  
 * |    | main()方法的栈祯                   |    |                                        |      |        ....        |    |      
 * |    | ---------------------|    |       |———————————————————|            |      |————————————————————     |  
 * |    |     局部变量s          |    |       |   主线程的程序计数器    |             |      |   main()方法的字节码  |                                  |  
 * |    |     局部变量a          |    |       ————————————————————             |       ————————————————————     |  
 * |    ---------主线程方法栈------    |                                        |                                |  
 * |                                |                                        |                                |  
 *  ————————————————————————————————                                          ————————————————————————————————
 * 
 * 方法区：存放了线程所执行的字节码指令，实例方法和静态方法的字节码都位于方法区，被所有的线程共享。
 * 堆区：存放了线程所操控的数据以对象的形式存放。
 * java栈区：线程的工作区，保存线程的运行状态。
 * 
 * 线程同步的特征：
 * 线程同步具有以下特征：
 * 1.如果一个同步代码块和非同步代码块同时操作共享资源。让然会造成对共享资源的竞争。因为当一个线程
 * 执行一个对象的同步代码块时候，其他线程让然可以执行对象的非同步代码块。所谓的线程之间的保持同步，
 * 是指不同的线程在执行同一个对象的同步代码块时候，因为要获得这个对象的锁而相互牵制。
 * 2.每个对象都有唯一的同步锁。
 * 3.在静态方法前面也可以使用synchronized修饰符。
 * 4.每个被加载到java虚拟机的方法区的类也有为一个的同步锁。
 * 5.当一个线程开始执行同步代码块时候，并不意味着必须以不中断的方式进行，进入同步代码块的线程也
 * 可以执行sleep或者yield方法，此时它并没有释放锁，只是把运行机会的cpu让给了其他的线程。
 * 6.synchroinzed声明不会被继承，如果一个用synchroinzed修饰的方法被子类覆盖，那么子类中这
 * 个方法不再保持同步，除非也用synchronized修饰。
 * 
 * 线程安全的类
 *   一个线程安全的类满足以下条件：
 *     1.这个类的对象可以同时被多个线程安全地访问。
 *     2.每个线程都能正常执行原子操作，得到正确的结果。
 *     3.在每个线程的原子操作都完成之后，对象处于逻辑上合理的状态。
 *            不可变类总是线程安全的，因为它的对象的状态始终不会变化，任何线程只能读取对象的状态，而不能改变它的状态。对于不可变类，如果要确保其线程安全。
 *     必须根据实际情况，对某些原子操作进行同步。
 *     可变类的线程安全往往以降低并发性能为代价，为了减小这个负面影响。
 *     可以采取以下措施：
 *     1.只对可能导致资源竞争的代码进行同步。
 *     2.如果一个可变类有两种运行环境，单线程运行环境和多线程运行环境，那么可以为这个类提供两种实现，
 *     在单线程运行环境中使用未采取同步类的实现，在多线程运行环境中使用采取同步的类的实现。所谓单线程运行环境是指类的对象只会被一个线程访问；
 *     所谓多线程运行环境，是指类的同一对象被多个线程同时访问。
 *     
 * 释放对象的锁
 *     由于等待一个锁的线程只有在获得这把锁之后，才能恢复运行，所以让持有锁的线程在不再需要锁的时候及时释放锁的很重要的。
 *在以下情况下，持有锁的线程会释放锁。
 *1.执行完同步代码块，就会释放锁。
 *2.在执行同步代码块的过程中，遇到异常而导致线程终止，锁也会被释放。
 *3.在执行同步代码块的过程中，执行了锁所属对象的wait方法，这个线程会释放锁，进入对象的等待池。
 *
 * 以下情况下，线程不会释放锁
 * 1.在执行同步代码块的过程中，执行了Thread.sleep方法，当前线程放弃cpu开始睡眠，在睡眠中不会释放锁。
 * 2.在执行同步代码块的过程中，执行了Thread.yield方法，当前线程放弃cpu，但是不会释放锁。
 * 3.执行同步代码块的过程中，其他线程执行了当前线程对象的suspend方法，当前线程被暂停，但是不会释放锁。
 * </pre>   
 *    
 *  <br/>
 * Date:     2015-3-23 上午10:13:53 <br/>
 * @author   longgangbai
 * @version  
 * @since    JDK 1.6
 * @see 	 
 */
public class MemoryStyle {
    private int a;//实例变量
    public int method(){
        int b=0;//局部变量
        a++;
        b=a;
        return b;
    }
    public static void main(String[] args) {
        MemoryStyle s=null;//局部变量
         int a=0;
         s=new MemoryStyle();
         a=s.method();
         System.out.println(a);
    }

}

